---
title: "CAPM Notebook"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---


```{r setup, include = FALSE}

library(tidyquant)
library(tidyverse)
library(timetk)
library(broom)
library(tibbletime)
library(highcharter)
library(scales)

knitr::opts_chunk$set(message=FALSE, warning=FALSE)

load("~/reproducible-fin-chapters/book-data.Rdata")
```

In this chapter, we will take a brief look at the Capital Asset Pricing Model, or CAPM.  

By way of extraordinarily brief background, CAPM 

We are going to focus on calculating the market beta of our portfolio and that number will tell us about our portfolio's relationship to the market return.  

We need to make a choice about which asset to use as a proxy for the market return and we will go with the SPY ETF, effectively treating the S&P500 as our market. That's going to make our calculations substantively uninteresting because (1) SPY is 25% of our portfolio and (2) we have chosen assets and a time period in which correlations with SPY have generally been high. With those caveats in mind, feel free to choose a different asset for the market return and try to reproduce this work, or construct a different portfolio that does not include SPY.  

Let's calculate our market return by extracting SPY from our `assets_returns_long` object.

```{r}
market_return <- asset_returns_long %>% 
  na.omit() %>% 
  filter(asset == "SPY") %>% 
  select(returns)
```

Now there are several ways to calculate portfolio beta but first let's have a look at the equation.

$${\beta}_i = cov(R_i, R_m)/\sigma_m $$

Portfolio beta is equal to the covariance of the portfolio returns and market returns, divided by the variance of market returns. 

```{r}
cov(portfolio_returns_xts_rebalanced_monthly, market_return$returns)/var(market_return$returns)
```


```{r}
beta_assets <- 
  asset_returns_long %>% 
  nest(-asset) %>% 
  mutate(model = map(data, ~ lm(returns ~ market_return$returns, data = .))) %>% 
  unnest(model %>% map(tidy)) %>% 
  filter(term == "market_return$returns") %>% 
  select(-term)
```

A quick sanity check on those asset betas should reveal that SPY has beta of 1 with itself. 

```{r}
beta_assets %>% select(asset, estimate)
```

Besides confirming SPY's beta = 1, do we notice anything else of interest? Well, EFA, IJS and EEM have betas close to 1, and AGG has a negative but small beta. Let's see how our combination of these assets leads to a portfolio beta.

The equation for portfolio beta is the weighted sum of the asset betas:

$${\beta}_{portfolio} ={\sum_{i=1}^n}W _i~{\beta}_i $$


We already have our portfolio weights from section 1 on portfolio retuns. We multiply them by the respective beta estimates.

```{r}
beta_byhand <- 
  w_1 * beta_assets$estimate[1] + 
  w_2 * beta_assets$estimate[2] + 
  w_3 * beta_assets$estimate[3] +
  w_4 * beta_assets$estimate[4] +
  w_5 * beta_assets$estimate[5]

beta_byhand
```

That beta is close 1, which is what we were expecting. Let's go to the `xts` world and use the built-in `CAPM.beta()` function from `PerformanceAnalytics`. That function takes two arguments: the returns for the portfolio (or any asset) whose beta we wish to calculate, and the market returns. Our function will look like `CAPM.beta(portfolio_returns_xts_rebalanced_monthly, mkt_return_xts)`.

```{r}
mkt_return_xts <- asset_returns_xts$SPY
beta_builtin_xts <- CAPM.beta(portfolio_returns_xts_rebalanced_monthly, mkt_return_xts)
```

We will run that same function through a `dplyr` and tidyquant code flow to stay in the tidy world.

First we'll use dplyr to grab our betas. We'll return to this flow later for some visualization but for now will extract the portfolio beta. To calculate the beta, we call 
`do(model = lm(returns ~ market_return$returns, data = .))`. Then we head to the `broom` package and use the `tidy()` function to make our model results a little easier on the eyes.

```{r}

beta_dplyr_byhand <-
  portfolio_returns_tq_rebalanced_monthly %>% 
  do(model = lm(returns ~ market_return$returns, data = .)) %>% 
  tidy(model) %>% 
  slice(-1) %>% 
  select(estimate)
```


```{r}
beta_builtin_tq <- 
  portfolio_returns_tq_rebalanced_monthly %>% 
  mutate(market_return = asset_returns_dplyr_byhand$SPY) %>% 
  na.omit() %>% 
  tq_performance(Ra = returns, 
                 Rb = market_return, 
                 performance_fun = CAPM.beta) %>% 
  `colnames<-`("beta_tq")
```
 
Let's take a quick look at our four beta calculations. 
 
```{r}
beta_byhand
beta_builtin_xts
beta_dplyr_byhand$estimate
beta_builtin_tq$beta_tq
```

Consistent results and a beta near 1 as we were expecting, since our portfolio has a 25% allocation to the S&P500 and the last few years have been a market regime of high correlations.  We're less concernced with number and more so with the various code flows used to get here. 

For visualization, let's return to that dplyr by-hand method and explore the `augment()` function from `broom`. 

The code chunk below will take our original model results and then add predicted values to the original data set. 

```{r, warning = FALSE}
portfolio_model_augmented <- 
portfolio_returns_tq_rebalanced_monthly %>% 
  do(model = lm(returns ~ market_return$returns, data = .)) %>% 
  augment(model)
```

Let's use `ggplot()` to see how well the fitted return values match the actual. 

```{r}
portfolio_model_augmented %>% 
  ggplot(aes(x = portfolio_returns_tq_rebalanced_monthly$date)) + 
  geom_line(aes(y = returns), color = "cornflowerblue") + 
  geom_line(aes(y = .fitted), color = "green") 
```


Those are monthly returns. How about growth of a dollar? 

```{r}
portfolio_model_augmented %>%
  mutate(actual_growth = cumprod(1 + returns), 
         fitted_growth = cumprod(1 + .fitted)) %>% 
  ggplot(aes(x = portfolio_returns_tq_rebalanced_monthly$date)) + 
  geom_line(aes(y = actual_growth), color = "cornflowerblue") + 
  geom_line(aes(y = fitted_growth), color = "green") +
  xlab("date") +
  ylab("actual and fitted growth") +
  scale_x_date(breaks = pretty_breaks(n= 8)) +
  scale_y_continuous(labels = dollar)

```

Our fitted growth looks pretty good, which again is unsurprising since we regressed on SPY, a big component of our portfolio. 

