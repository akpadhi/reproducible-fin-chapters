---
title: "CAPM Notebook"
output:
     pdf_document:
         latex_engine: xelatex
---


```{r setup, include = FALSE}

library(tidyquant)
library(tidyverse)
library(timetk)
library(broom)
library(tibbletime)
library(highcharter)
library(scales)

knitr::opts_chunk$set(message=FALSE, warning=FALSE)

load("~/reproducible-fin-chapters/book-data.Rdata")
```

In this chapter, we will take a brief look at the Capital Asset Pricing Model, or CAPM.  

By way of extraordinarily brief background, CAPM 

We are going to focus on calculating the market beta of our portfolio and that number will tell us about our portfolio's relationship to the market return.  

We need to make a choice about which asset to use as a proxy for the market return and we will go with the SPY ETF, effectively treating the S&P500 as our market. That's going to make our calculations substantively uninteresting because (1) SPY is 25% of our portfolio and (2) we have chosen assets and a time period in which correlations with SPY have generally been high. With those caveats in mind, feel free to choose a different asset for the market return and try to reproduce this work, or construct a different portfolio that does not include SPY.  

Let's calculate our market return by extracting SPY from our `assets_returns_long` object.

```{r}
market_return <- asset_returns_long %>% 
  na.omit() %>% 
  filter(asset == "SPY") %>% 
  select(returns)
```

Now there are several ways to calculate portfolio beta but first let's have a look at the equation.

$${\beta}_{portfolio} = cov(R_p, R_m)/\sigma_m $$

Portfolio beta is equal to the covariance of the portfolio returns and market returns, divided by the variance of market returns.

We can calculate the numerator, or covariance of portfolio and market returns, with `cov(portfolio_returns_xts_rebalanced_monthly, market_return$returns)` and the denominator with
`var(market_return$returns)`. 

Our portfolio beta is equal to:

```{r}
cov(portfolio_returns_xts_rebalanced_monthly, market_return$returns)/var(market_return$returns)
```

That beta is quite near to 1 as we were expecting. 

We can also calculate portfolio beta by finding the beta of each of our assets and then multiplying by asset weights. That is, another equation for portfolio beta is the weighted sum of the asset betas:

$${\beta}_{portfolio} ={\sum_{i=1}^n}W _i~{\beta}_i $$

To use that method, we first find the beta for each of our assets and this gives us an opportunity to introduce a code flow for running regression analysis.  We want to regress each of our individual asset returns on the market return.  We could do that for asset 1 with `lm(asset_return_1 ~ market_return$returns)`, and then again for asset 2 with `lm(asset_return_2 ~ market_return$returns)` etc for all 5 of our assets.  But if we had a 50 asset portfolio, that would be impractical. Instead let's write a code flow and use `map()` to regress all of our assets and calculate betas with one call. 

We will start with our `asset_returns_long` tidy data frame and will then run `nest(-asset)`.

```{r}
beta_assets <- 
  asset_returns_long %>% 
  nest(-asset)

beta_assets
```

That `nest(-asset)` changed our data frame so that there are two columns: one called `asset` that holds our asset name and one called `data` that holds a list of returns for each asset. We have now 'nested' a list of returns within a column.

Now we can use `map()` to apply a function to each of those nested lists and store the results in a new column. `mutate()` is how we create a new column. The whole piped command is
`mutate(model = map(data, ~ lm(returns ~ market_return$returns, data = .))) `

```{r}
beta_assets <- 
  asset_returns_long %>% 
  nest(-asset) %>% 
  mutate(model = map(data, ~ lm(returns ~ market_return$returns, data = .))) 

beta_assets
```

We now have 3 columns: `asset` which we had before, `data` which we had before, and `model` which we just added. The model column holds the results of the regression `lm(returns ~ market_return$returns, data = .)` that we ran for each of our assets. Those results are a beta and an intercept.

```{r}
beta_assets$model
```

We have our beta for each asset but not in a great format for presenation or even readabiity. 

Let's tidy up our results with the `tidy()` function from the `broom` package. We want to apply that function to our model column and will use the `mutate()` and `map()` combination again. The complete call is to
`mutate(model = map(model, tidy)) %>%`

I don't like having nested lists in my final results so we will `unnest()` our `model` column.

```{r}
beta_assets <- 
  asset_returns_long %>% 
  nest(-asset) %>% 
  mutate(model = map(data, ~ lm(returns ~ market_return$returns, data = .))) %>%
  mutate(model = map(model, tidy))

beta_assets
```

We are getting close now but the model `column` holds nested data frames. Have a look and see that they are nicely formatted data frames: 

```{r}
beta_assets$model
```

Still, I don't like to end up with nested data frames, so let's `unnest()` that `model` column.

```{r}
beta_assets <- 
  asset_returns_long %>% 
  nest(-asset) %>% 
  mutate(model = map(data, ~ lm(returns ~ market_return$returns, data = .))) %>%
  mutate(model = map(model, tidy)) %>% 
  unnest(model)

beta_assets
```

Now that looks human readable and presentable. We will do one further cleanup and get rid of the intercept results since we are not going to use them. 

```{r}
beta_assets <- 
  asset_returns_long %>% 
  nest(-asset) %>% 
  mutate(model = map(data, ~ lm(returns ~ market_return$returns, data = .))) %>% 
  unnest(model %>% map(tidy)) %>% 
  filter(term == "market_return$returns") %>% 
  select(-term)

beta_assets
```

A quick sanity check on those asset betas should reveal that SPY has beta of 1 with itself. 

```{r}
beta_assets %>% select(asset, estimate)
```

Besides confirming SPY's beta = 1, do we notice anything else of interest? Well, EFA, IJS and EEM have betas close to 1, and AGG has a negative but small beta. Let's see how our combination of these assets leads to a portfolio beta.

We already have our portfolio weights from section 1 on portfolio retuns. We multiply them by the respective beta estimates.

```{r}
beta_byhand <- 
  w_1 * beta_assets$estimate[1] + 
  w_2 * beta_assets$estimate[2] + 
  w_3 * beta_assets$estimate[3] +
  w_4 * beta_assets$estimate[4] +
  w_5 * beta_assets$estimate[5]

beta_byhand
```

That beta is the same as we calculated above and now we know the the covariance of portfolio returns and market returns divided by the variance of market returns is equal to the weighted estimates we got by regressing each asset's return on market returns. 

We can make things even more efficient, of course, with built-in functios. Let's go to the `xts` world and use the built-in `CAPM.beta()` function from `PerformanceAnalytics`. That function takes two arguments: the returns for the portfolio (or any asset) whose beta we wish to calculate, and the market returns. Our function will look like `CAPM.beta(portfolio_returns_xts_rebalanced_monthly, mkt_return_xts)`.

```{r}
mkt_return_xts <- asset_returns_xts$SPY
beta_builtin_xts <- CAPM.beta(portfolio_returns_xts_rebalanced_monthly, mkt_return_xts)

beta_builtin_xts
```

We will run that same function through a `dplyr` and tidyquant code flow to stay in the tidy world.

First we'll use dplyr to grab our betas. We'll return to this flow later for some visualization but for now will extract the portfolio beta. 

To calculate the beta, we call 
`do(model = lm(returns ~ market_return$returns, data = .))`. Then we head back to the `broom` package and use the `tidy()` function to make our model results a little easier on the eyes.

```{r}

beta_dplyr_byhand <-
  portfolio_returns_tq_rebalanced_monthly %>% 
  do(model = lm(returns ~ market_return$returns, data = .)) %>% 
  tidy(model) %>% 
  slice(-1) %>% 
  select(estimate)

beta_dplyr_byhand
```

One more flow for built-in functions using `tidyquant` and the `tq_performance()` function.

```{r}
beta_builtin_tq <- 
  portfolio_returns_tq_rebalanced_monthly %>% 
  mutate(market_return = asset_returns_dplyr_byhand$SPY) %>% 
  na.omit() %>% 
  tq_performance(Ra = returns, 
                 Rb = market_return, 
                 performance_fun = CAPM.beta) %>% 
  `colnames<-`("beta_tq")
```
 
Let's take a quick look at our four beta calculations. 
 
```{r}
beta_byhand
beta_builtin_xts
beta_dplyr_byhand$estimate
beta_builtin_tq$beta_tq
```

Consistent results and a beta near 1 as we were expecting, since our portfolio has a 25% allocation to the S&P500 and the last few years have been a market regime of high correlations.  We're less concernced with number and more so with the various code flows used to get here. 

[A WORD ON THOSE FLOWS]

Now on to visualization.

For visualization, let's return to that dplyr by-hand method and explore the `augment()` function from `broom`. 

The code chunk below will take our model results and then the `augment()` function will add predicted values to the original data set. 

```{r, warning = FALSE}
portfolio_model_augmented <- 
portfolio_returns_tq_rebalanced_monthly %>% 
  do(model = lm(returns ~ market_return$returns, data = .)) %>% 
  augment(model)

portfolio_model_augmented
```

Let's use `ggplot()` to see how well the fitted return values match the actual return values. 

```{r}
portfolio_model_augmented %>% 
  ggplot(aes(x = portfolio_returns_tq_rebalanced_monthly$date)) + 
  geom_line(aes(y = returns), color = "cornflowerblue") + 
  geom_line(aes(y = .fitted), color = "green") 
```


Those are monthly returns. How about growth of a dollar? 

```{r}
portfolio_model_augmented %>%
  mutate(actual_growth = cumprod(1 + returns), 
         fitted_growth = cumprod(1 + .fitted)) %>% 
  ggplot(aes(x = portfolio_returns_tq_rebalanced_monthly$date)) + 
  geom_line(aes(y = actual_growth), color = "cornflowerblue") + 
  geom_line(aes(y = fitted_growth), color = "green") +
  xlab("date") +
  ylab("actual and fitted growth") +
  scale_x_date(breaks = pretty_breaks(n= 8)) +
  scale_y_continuous(labels = dollar)

```

Our fitted growth looks pretty good, which again is unsurprising since we regressed on SPY, a big component of our portfolio. 

Closing thoughts on beta and modeling? 
